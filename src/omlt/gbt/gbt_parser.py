import numpy as np
from omlt.gbt.model import GradientBoostedTreeModel
from collections import defaultdict
from collections import deque


class GradientBoostedTreeData:
    def __init__(self, onnx_model):
        """
        Create a network definition object used to create the gradient-boosted trees
        formulation in Pyomo

        Args:
           onnx_model : ONNX Model
              An ONNX model that is generated by the ONNX convert function for
              lightgbm.
           scaling_object : ScalingInterface or None
              A scaling object to specify the scaling parameters for the
              tree ensemble inputs and outputs. If None, then no
              scaling is performed.
           scaled_input_bounds : dict or None
              A dict that contains the bounds on the scaled variables (the
              direct inputs to the tree ensemble). If None, then no bounds
              are specified or they are generated using unscaled bounds.
        """
        self.__model = onnx_model
        self.__n_inputs = _model_num_inputs(onnx_model)
        self.__n_outputs = _model_num_outputs(onnx_model)
        self.leaves, self.splits = _get_model_data(onnx_model)


def _model_num_inputs(model):
    """Returns the number of input variables"""
    graph = model.graph
    assert len(graph.input) == 1
    return _tensor_size(graph.input[0])


def _model_num_outputs(model):
    """Returns the number of output variables"""
    graph = model.graph
    assert len(graph.output) == 1
    return _tensor_size(graph.output[0])


def _tensor_size(tensor):
    """Returns the size of an input tensor"""
    tensor_type = tensor.type.tensor_type
    size = None
    for dim in tensor_type.shape.dim:
        if dim.dim_value is not None and dim.dim_value > 0:
            assert size is None
            size = dim.dim_value
    assert size is not None
    return size


def _node_attributes(node):
    attr = dict()
    for at in node.attribute:
        attr[at.name] = at
    return attr


def find_all_children_splits(split, splits_dict):
    """
    This helper function finds all multigeneration children splits for an 
    argument split.

    Arguments:
        split --The split for which you are trying to find children splits
        splits_dict -- A dictionary of all the splits in the tree

    Returns:
        A list containing the Node IDs of all children splits
    """
    all_splits = []

    # Check if the immediate left child of the argument split is also a split.
    # If so append to the list then use recursion to generate the remainder
    left_child = splits_dict[split]['children'][0]
    if left_child in splits_dict:
        all_splits.append(left_child)
        all_splits.extend(find_all_children_splits(left_child, splits_dict))

    # Same as above but with right child
    right_child = splits_dict[split]['children'][1]
    if right_child in splits_dict:
        all_splits.append(right_child)
        all_splits.extend(find_all_children_splits(right_child, splits_dict))

    return all_splits


def find_all_children_leaves(split, splits_dict, leaves_dict):
    """
    This helper function finds all multigeneration children leaves for an 
    argument split.

    Arguments:
        split -- The split for which you are trying to find children leaves
        splits_dict -- A dictionary of all the split info in the tree
        leaves_dict -- A dictionary of all the leaf info in the tree

    Returns:
        A list containing all the Node IDs of all children leaves
    """
    all_leaves = []

    # Find all the splits that are children of the relevant split
    all_splits = find_all_children_splits(split, splits_dict)

    # Ensure the current split is included
    if split not in all_splits:
        all_splits.append(split)

    # For each leaf, check if the parents appear in the list of children
    # splits (all_splits). If so, it must be a leaf of the argument split
    for leaf in leaves_dict:
        if leaves_dict[leaf]['parent'] in all_splits:
            all_leaves.append(leaf)

    return all_leaves


def reassign_none_bounds(leaves, input_bounds, features):
    """
    This helper function reassigns bounds that are None to the bounds
    input by the user

    Arguments:
        leaves -- The dictionary of leaf information. Attribute of the 
            LinearTreeModel object
        input_bounds -- The nested dictionary

    Returns:
        The modified leaves dict without any bounds that are listed as None
    """
    L = np.array(list(leaves.keys()))
    # features = np.arange(0, len(set(nodes_feature_ids)))

    for l in L:
        for f in features:
            if leaves[l]['bounds'][f][0] == None:
                leaves[l]['bounds'][f][0] = input_bounds[f][0]
            if leaves[l]['bounds'][f][1] == None:
                leaves[l]['bounds'][f][1] = input_bounds[f][1]

    return leaves


def _get_model_data(model_definition):
    if isinstance(model_definition, GradientBoostedTreeModel):
        gbt = model_definition.onnx_model
    else:
        gbt = model_definition
    graph = gbt.graph

    root_node = graph.node[0]
    attr = _node_attributes(root_node)

    # base_values don't apply to lgbm models
    base_value = (
        np.array(attr["base_values"].floats)[0] if "base_values" in attr else 0.0
    )

    nodes_feature_ids = np.array(attr["nodes_featureids"].ints)
    nodes_values = np.array(attr["nodes_values"].floats)
    nodes_modes = np.array(attr["nodes_modes"].strings)
    nodes_tree_ids = np.array(attr["nodes_treeids"].ints)
    nodes_node_ids = np.array(attr["nodes_nodeids"].ints)
    nodes_false_node_ids = np.array(attr["nodes_falsenodeids"].ints)
    nodes_true_node_ids = np.array(attr["nodes_truenodeids"].ints)
    nodes_hitrates = np.array(attr["nodes_hitrates"].floats)
    nodes_missing_value_tracks_true = np.array(
        attr["nodes_missing_value_tracks_true"].ints
    )

    n_targets = attr["n_targets"].i
    target_ids = np.array(attr["target_ids"].ints)
    target_node_ids = np.array(attr["target_nodeids"].ints)
    target_tree_ids = np.array(attr["target_treeids"].ints)
    target_weights = np.array(attr["target_weights"].floats)
    nodes_leaf_mask = nodes_modes == b"LEAF"
    nodes_branch_mask = nodes_modes == b"BRANCH_LEQ"

    tree_ids = set(nodes_tree_ids)
    feature_ids = set(nodes_feature_ids)
    splits_dic = defaultdict(dict)
    leaves_dic = defaultdict(dict)
    for i in tree_ids:
        # splits_dic[i] = {"node": nodes_node_ids[nodes_tree_ids==i]}
        node = nodes_node_ids[nodes_tree_ids == i]
        feature = nodes_feature_ids[nodes_tree_ids == i]
        value = nodes_values[nodes_tree_ids == i]
        mode = nodes_modes[nodes_tree_ids == i]
        target_weight = target_weights[target_tree_ids == i]
        count = 0
        count_leaf = 0
        queue = deque([node[count]])
        while queue:
            cur = queue[0]
            queue.popleft()
            if mode[cur] == b'BRANCH_LEQ':
                splits_dic[i][cur] = {'th': value[cur],
                                    'col': feature[cur],
                                    'children': [None, None]}
                queue.appendleft(node[count + 2])
                splits_dic[i][cur]['children'][0] = node[count + 1]
                queue.appendleft(node[count + 1])
                splits_dic[i][cur]['children'][1] = node[count + 2]
                count += 2
            else:
                leaves_dic[i][cur] = {'val': target_weight[count_leaf]}
                count_leaf += 1

    for i in tree_ids:
        splits = splits_dic[i]
        leaves = leaves_dic[i]
        for split in splits:
            left_child = splits[split]['children'][0]
            right_child = splits[split]['children'][1]
            if left_child in splits:
                splits[left_child]['parent'] = split
            else:
                leaves[left_child]['parent'] = split

            if right_child in splits:
                splits[right_child]['parent'] = split
            else:
                leaves[right_child]['parent'] = split

    for i in tree_ids:
        splits = splits_dic[i]
        leaves = leaves_dic[i]
        for split in splits:
            # print("split:" + str(split))
            left_child = splits[split]['children'][0]
            right_child = splits[split]['children'][1]

            if left_child in splits:
                # means left_child is split
                splits[split]['left_leaves'] = find_all_children_leaves(
                    left_child, splits, leaves
                )
            else:
                # means left_child is leaf
                splits[split]['left_leaves'] = [left_child]
                # print("left_child" + str(left_child))

            if right_child in splits:
                splits[split]['right_leaves'] = find_all_children_leaves(
                    right_child, splits, leaves
                )
            else:
                splits[split]['right_leaves'] = [right_child]
                # print("right_child" + str(right_child))

    n_inputs = _model_num_inputs(model_definition)
    features = np.arange(0, n_inputs)

    for i in tree_ids:
        splits = splits_dic[i]
        leaves = leaves_dic[i]
        for leaf in leaves:
            leaves[leaf]['bounds'] = {}
        for th in features:
            for leaf in leaves:
                leaves[leaf]['bounds'][th] = [None, None]
        import pprint
        pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(splits)
        #pp.pprint(leaves)
        for split in splits:
            var = splits[split]['col']
            for leaf in splits[split]['left_leaves']:
                #print(leaf)
                leaves[leaf]['bounds'][var][1] = splits[split]['th']

            for leaf in splits[split]['right_leaves']:
                leaves[leaf]['bounds'][var][0] = splits[split]['th']
    # for t in tree_ids:
    #     leaves_dic[t] = reassign_none_bounds(
    #         leaves_dic[t], model_definition.scaled_input_bounds, features)
    
    return leaves_dic, splits_dic