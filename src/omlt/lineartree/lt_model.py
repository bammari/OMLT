import numpy as np


class LinearTreeModel:
    """
    Class to represent a linear tree model trained in the linear-tree package

    Attributes:
        __model (linear-tree model) : Linear Tree Model trained in linear-tree
        __splits (dict) : Dict containing split information
        __leaves (dict) : Dict containing leaf information
        __thresholds (dict) : Dict containing splitting threshold information
        __scaling_object (scaling object) : Scaling object to ensure scaled 
            data match units of broader optimization problem
        __scaled_input_bounds (dict): Dict containing scaled input bounds

    References:
        * linear-tree : https://github.com/cerlymarco/linear-tree
        * Ammari et al. (2023) Linear Model Decision Trees as Surrogates in
            Optimization for Engineering Applications
        * Misic, V. "Optimization of tree ensembles." 
             Operations Research 68.5 (2020): 1605-1624.
        * Mistry, M., et al. "Mixed-integer convex nonlinear optimization 
             with gradient-boosted trees embedded." INFORMS Journal on 
             Computing (2020). 
    """

    def __init__(
        self, lt_model, scaling_object=None, scaled_input_bounds=None
        ):
        """ 
        Create a LinearTreeModel object used to create the linear model tree
        formulation in Pyomo

           scaling_object : ScalingInterface or None
              A scaling object to specify the scaling parameters for the
              linear model tree inputs and outputs. If None, then no
              scaling is performed.
           scaled_input_bounds : dict or None
              A dict that contains the bounds on the scaled variables (the
              direct inputs to the tree ensemble). If None, then no bounds
              are specified or they are generated using unscaled bounds.

        Arguments:
            lt_model -- An linear-tree model that is generated by the 
                linear-tree package

        Keyword Arguments:
            scaling_object -- A scaling object to specify the scaling 
                parameters for the linear model tree inputs and outputs. 
                If None, then no scaling is performed. (default: {None})
            scaled_input_bounds -- A dict that contains the bounds on the 
                scaled variables (the direct inputs to the tree ensemble). 
                If None, then no bounds are specified or they are generated 
                using unscaled bounds.(default: {None})
        """
        self._model = lt_model
        self._splits, self._leaves, self._thresholds =\
            parse_Tree_Data(lt_model)
        self._scaling_object = scaling_object
        self._scaled_input_bounds = scaled_input_bounds
        self._n_inputs = find_n_inputs(self._leaves)
        self._n_outputs = 1


def find_all_children_splits(split, splits_dict):
    """
    This helper function finds all multigeneration children splits for an 
    argument split.

    Arguments:
        split --The split for which you are trying to find children splits
        splits_dict -- A dictionary of all the splits in the tree

    Returns:
        A list containing the Node IDs of all children splits
    """
    all_splits = []

    # Check if the immediate left child of the argument split is also a split. 
    # If so append to the list then use recursion to generate the remainder
    left_child = splits_dict[split]['children'][0]
    if left_child in splits_dict:
        all_splits.append(left_child)
        all_splits.extend(find_all_children_splits(left_child, splits_dict))
    
    # Same as above but with right child
    right_child = splits_dict[split]['children'][1]
    if right_child in splits_dict:
        all_splits.append(right_child)
        all_splits.extend(find_all_children_splits(right_child, splits_dict))
    
    return all_splits


def find_all_children_leaves(split, splits_dict, leaves_dict):
    """
    This helper function finds all multigeneration children leaves for an 
    argument split.

    Arguments:
        split -- The split for which you are trying to find children leaves
        splits_dict -- A dictionary of all the split info in the tree
        leaves_dict -- A dictionary of all the leaf info in the tree

    Returns:
        A list containing all the Node IDs of all children leaves
    """
    all_leaves = []

    # Find all the splits that are children of the relevant split
    all_splits = find_all_children_splits(split, splits_dict)
    
    # Ensure the current split is included 
    if split not in all_splits:
        all_splits.append(split)
    
    # For each leaf, check if the parents appear in the list of children 
    # splits (all_splits). If so, it must be a leaf of the argument split
    for leaf in leaves_dict:
        if leaves_dict[leaf]['parent'] in all_splits:
            all_leaves.append(leaf)
    
    return all_leaves


def find_n_inputs(leaves):
    """
    Finds the number of inputs using the length of the slope vector in the 
    first leaf

    Arguments:
        leaves -- Dictionary of leaf information

    Returns:
        Number of inputs
    """
    L = np.array(list(leaves.keys()))
    n_inputs = len(np.arange(0,len(leaves[L[0]]['slope'])))
    return n_inputs


def parse_Tree_Data(model):
    """
    This function creates the data structures with the information required
    for creation of the variables, sets, and constraints in the pyomo
    reformulation of the linear model decision trees. Note that these data
    structures are attributes of the LinearTreeModel Class.

    Arguments:
        model -- Trained linear-tree model

    Returns:
        leaves - Dict containing the following information for each leaf:
            1) 'slope' - The slope of the fitted line at that leaf
            2) 'intercept' - The intercept of the line at that lead
            3) 'parent' - The parent split or node of that leaf
        splits - Dict containing the following information for each split:
            1) 'children' - The child nodes of that split
            2) 'col' - The variable(feature) to split on (beginning at 0)
            3) 'left_leaves' - All the leaves to the left of that split
            4) 'right_leaves' - All the leaves to the right of that split
            5) 'parent' - The parent node of the split. Node zero has no parent
            6) 'th' - The threshold of the split
            7) 'y_index' - Indices corresponding to Mistry et. al. y binary
                    variable
        vars_dict - Dict of tree inputs and their respective thresholds
    """
    # Create the initial leaves and splits dictionaries 
    leaves = model.summary(only_leaves=True)
    splits = model.summary()

    # This loop adds keys for the slopes and intercept. 
    for leaf in leaves:
        del splits[leaf]
        leaves[leaf]['slope'] = list(leaves[leaf]['models'].coef_)
        leaves[leaf]['intercept'] = leaves[leaf]['models'].intercept_
    
    # This loop creates an parent node id entry for each node in the tree
    for split in splits:
        left_child = splits[split]['children'][0]
        right_child = splits[split]['children'][1]

        if left_child in splits:
            splits[left_child]['parent'] = split
        else:
            leaves[left_child]['parent'] = split
        
        if right_child in splits:
            splits[right_child]['parent'] = split
        else:
            leaves[right_child]['parent'] = split
    
    # This loop creates an entry for the all the leaves to the left and right
    # of a split
    for split in splits:
        left_child = splits[split]['children'][0]
        right_child = splits[split]['children'][1]
        
        if left_child in splits:
            splits[split]['left_leaves'] = find_all_children_leaves(
                left_child, splits, leaves
                )
        else:
            splits[split]['left_leaves'] = [left_child]
        
        if right_child in splits:
            splits[split]['right_leaves'] = find_all_children_leaves(
                right_child, splits, leaves
                )
        else:
            splits[split]['right_leaves'] = [right_child]

    # For each variable that appears in the tree, go through all the splits
    # and record its splitting threshold
    splitting_thresholds = {}
    for split in splits:
        var = splits[split]['col']
        splitting_thresholds[var] = {}
    for split in splits:
        var = splits[split]['col']
        splitting_thresholds[var][split] = splits[split]['th']

    # Make sure every nested dictionary in the splitting_thresholds dictionary 
    # is sorted by value
    for var in splitting_thresholds:
       splitting_thresholds[var] = dict(
           sorted(splitting_thresholds[var].items(), key=lambda x: x[1])
           )

    # TODO Can eliminate if not implementing the Mistry et. al. formulations
    # Record the ordered indices of the binary variable y. The first index
    # is the splitting variable. The second index is its location in the 
    # ordered dictionary of thresholds for that variable.
    for split in splits:
        var = splits[split]['col']
        splits[split]['y_index'] = []
        splits[split]['y_index'].append(var)
        splits[split]['y_index'].append(
            list(splitting_thresholds[var]).index(split)
            )

    # For each leaf, create an empty dictionary that will store the lower 
    # and upper bounds of each feature.
    for leaf in leaves:
        leaves[leaf]['bounds'] = {}
    
    L = np.array(list(leaves.keys()))
    features = np.arange(0,len(leaves[L[0]]['slope']))
    
    # For each feature in each leaf, initialize lower and upper bounds to None
    for th in features:
        for leaf in leaves:
            leaves[leaf]['bounds'][th] = [None, None]

    # TODO Can implement recursion here as well to eliminate nested loops.
    # Finally, go through each split and assign it's threshold value as the
    # upper bound to all the leaves descending to the left of the split and
    # as the lower bound to all the leaves descending to the right.
    for split in splits:
        var = splits[split]['col']
        for leaf in splits[split]['left_leaves']:
            leaves[leaf]['bounds'][var][1] = splits[split]['th']
        
        for leaf in splits[split]['right_leaves']:
            leaves[leaf]['bounds'][var][0] = splits[split]['th']

    return splits, leaves, splitting_thresholds