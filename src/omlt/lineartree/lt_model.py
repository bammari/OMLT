import numpy as np

class LinearTreeModel:
    """
    Class to represent a linear tree model trained in the linear-tree package

    Attributes:
        __model (linear-tree model) : Linear Tree Model trained in linear-tree
        __splits (dict) : Dict containing split information
        __leaves (dict) : Dict containing leaf information
        __thresholds (dict) : Dict containing splitting threshold information
        __scaling_object (scaling object) : Scaling object to ensure scaled 
            data match units of broader optimization problem
        __scaled_input_bounds (dict): Dict containing scaled input bounds

    References:
        linear-tree : https://github.com/cerlymarco/linear-tree 
    """

    def __init__(
        self, lt_model, scaling_object=None, scaled_input_bounds=None
        ):
        """
        Create a LinearTreeModel object used to create the linear model tree
        formulation in Pyomo

        Args:
           lt_model : linear-tree model
              An linear-tree model that is generated by the linear-tree package 
           scaling_object : ScalingInterface or None
              A scaling object to specify the scaling parameters for the
              linear model tree inputs and outputs. If None, then no
              scaling is performed.
           scaled_input_bounds : dict or None
              A dict that contains the bounds on the scaled variables (the
              direct inputs to the tree ensemble). If None, then no bounds
              are specified or they are generated using unscaled bounds.
        """
        self.__model = lt_model
        self.__splits, self.__leaves, self.__thresholds =\
            _parse_Tree_Data(lt_model)
        self.__scaling_object = scaling_object
        self.__scaled_input_bounds = scaled_input_bounds


# TODO: Pull out and make sure doesn't need global variabes
def find_all_children_splits(split, splits_dict):
    """
    This helper function finds all multigeneration children splits for an 
    argument split.

    Args:
        split : The split for which you are trying to find children splits
        splits_dict: A dictionary of all the splits in the tree
    
    Returns:
        all_splits : A list containing the Node IDs of all children splits
    """
    # We will store all the split ids in a list.
    all_splits = []

    # Check if the immediate left child of the argument split is also a split. If so
    # append to the list
    left_child = splits_dict[split]['children'][0]
    if left_child in splits_dict:
        all_splits.append(left_child)
        all_splits.extend(find_all_children_splits(left_child, splits_dict))
    
    # Same as above but with right child
    right_child = splits_dict[split]['children'][1]
    if right_child in splits_dict:
        all_splits.append(right_child)
        all_splits.extend(find_all_children_splits(right_child, splits_dict))
    
    return all_splits

def _parse_Tree_Data(model):

    # Create the initial leaves and splits dictionaries. These are attributes of the 
    # LinearModelTree Objet 
    leaves = model.summary(only_leaves=True)
    splits = model.summary()
    
    def find_all_children_leaves(split):
        """
        This function finds all multigeneration children leaves for an argument split.
        """
        # Store the ids of the leaves in a list
        all_leaves = []
        # Find all the splits that are children of the relevant split
        all_splits = find_all_children_splits(split)
        print(all_splits)
        # If the current split not in all splits, append it to the list
        if split not in all_splits:
            all_splits.append(split)
        # For each leaf, check if the parents appear in the list of splits. If so,
        # It must be a leaf of the split
        for leaf in leaves:
            if leaves[leaf]['parent'] in all_splits:
                all_leaves.append(leaf)
        
        return all_leaves

    # This loop removes unnecessary entries from the leaves dictionary and adds keys
    # for the slope and intercept. Also removes leaves from the splits dictionary
    for leaf in leaves:
        del splits[leaf]
        del leaves[leaf]['samples']
        leaves[leaf]['slope'] = list(leaves[leaf]['models'].coef_)
        leaves[leaf]['intercept'] = leaves[leaf]['models'].intercept_
        del leaves[leaf]['models']
    
    # This loop removes unnecessary entries from the splits dictionary. This loop
    # also creates an entry for each leaf or split in the tree that indicates which split
    # is its parent
    for split in splits:
        del splits[split]['loss']
        del splits[split]['samples']
        del splits[split]['models']

        left_child = splits[split]['children'][0]
        right_child = splits[split]['children'][1]

        if left_child in splits:
            splits[left_child]['parent'] = split
        else:
            leaves[left_child]['parent'] = split
        
        if right_child in splits:
            splits[right_child]['parent'] = split
        else:
            leaves[right_child]['parent'] = split
    
    # This loop goes through all the splits and determines gets a list of all
    # the leaves to the left of a split and all the leaves to the right of a split
    for split in splits:
        left_child = splits[split]['children'][0]
        right_child = splits[split]['children'][1]
        if left_child in splits:
            splits[split]['left_leaves'] = find_all_children_leaves(
                left_child
                )
        else:
            splits[split]['left_leaves'] = [left_child]
        if right_child in splits:
            splits[split]['right_leaves'] = find_all_children_leaves(
                right_child
                )
        else:
            splits[split]['right_leaves'] = [right_child]

    # For each variable that appears in the tree, go through all the splits
    # and assign its splitting threshold to the correct entry in this nested dictionary
    splitting_thresholds = {}
    for split in splits:
        var = splits[split]['col']
        splitting_thresholds[var] = {}
    for split in splits:
        var = splits[split]['col']
        splitting_thresholds[var][split] = splits[split]['th']

    # Make sure every nested dictionary in the vars_dict dictionary is sorted by value since
    # this plays an important role in the ordering of the indices of binary variables y_ij in the Misic 
    # formulation
    for var in splitting_thresholds:
       splitting_thresholds[var] = dict(sorted(splitting_thresholds[var].items(), key=lambda x: x[1]))

    # Once the splitting threshold dictionary
    for split in splits:
        var = splits[split]['col']
        splits[split]['y_index'] = []
        splits[split]['y_index'].append(splits[split]['col'])
        splits[split]['y_index'].append(list(splitting_thresholds[var]).index(split))

    # Go through and 
    for leaf in leaves:
        leaves[leaf]['bounds'] = {}
    
    L = np.array(list(leaves.keys()))
    features = np.arange(0,len(leaves[L[0]]['slope']))
    for th in features:
        for leaf in leaves:
            leaves[leaf]['bounds'][th] = [None, None]

    for split in splits:
        for leaf in splits[split]['left_leaves']:
            leaves[leaf]['bounds'][splits[split]['col']][1] = splits[split]['th']
        
        for leaf in splits[split]['right_leaves']:
            leaves[leaf]['bounds'][splits[split]['col']][0] = splits[split]['th']

    return splits, leaves, splitting_thresholds